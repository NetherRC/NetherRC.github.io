<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[学习笔记-后缀数组]]></title>
    <url>%2F2019%2F12%2F24%2F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[后缀数组后缀数组是处理字符串的有力工具一些定义后缀: 从某个位置 i 开始到串末尾结束的特殊子串，记作 \mbox{Suffix}(i) ，即 \mbox{Suffix}(i)=S_{i \ldots |S|} 最长公共前缀 / LCP: 两个串 S, T 的最长公共前缀就是满足 S_{1 \ldots x}=T_{1 \ldots x} 的最大的 x ，记作 \mbox{LCP}(S, T) 后缀数组: 后缀数组 \mbox{SA} 记录的是 1 \ldots n 的一个排列，满足 \mbox{Suffix}(\mbox{SA}_i) &lt; \mbox{Suffix}(\mbox{SA}_{i+1}) 名次数组: 名次数组 \mbox{rank} 记录的是 \mbox{Suffix}(i) 在 S 所有后缀的名次 显然， \mbox{rank} 和 \mbox{SA} 为互逆运算 \mbox{height} 数组: \mbox{height} 数组记录的是 \mbox{Suffix}(\mbox{SA}_{i-1}) 和 \mbox{Suffix}(\mbox{SA}_i) 的 \mbox{LCP} ，即 \mbox{height}_i=\mbox{LCP}(\mbox{Suffix}(\mbox{SA}_{i-1}),\mbox{Suffix}(\mbox{SA}_i)) 特别的， \mbox{height}_1=0 后缀数组的构建 我们有一个朴素的做法，将 |S| 个后缀拿出来 sort 因为字符串比较是 O(n) 的，所以时间复杂度为 O(n^2 \log n) ，显然不能满足需求 倍增算法 先对每个后缀按照首字母排序 假设我们已经知道了按照前 w 个字母排序的排名 \mbox{Rank}_{w, 1 \dots n} 那么，我们按照 \mbox{Rank}_{w, i} 为第一关键字， \mbox{Rank}_{w, i+w} 为第二关键字排序，就可以得到 \mbox{Rank}_{2w} ，特别的，若 i+w &gt; n ，则令 \mbox{Rank}_{w, i+w}=0 时间复杂度为 O(n \log^2 n) ，还不够优秀 一些优化]]></content>
      <categories>
        <category>String</category>
      </categories>
      <tags>
        <tag>Sort</tag>
        <tag>Suffix</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[任务计划-多项式题单]]></title>
    <url>%2F2019%2F12%2F23%2F%E4%BB%BB%E5%8A%A1%E8%AE%A1%E5%88%92-%E5%A4%9A%E9%A1%B9%E5%BC%8F%E9%A2%98%E5%8D%95%2F</url>
    <content type="text"><![CDATA[多项式题单这里记录了 Hatate 在学习多项式时做的一些题目CF 1251F如果每种长度的白板都只有一块，则取 k 块板的答案为 2^k \left( \begin{matrix} n \\ k \end{matrix} \right) 考虑有长度相同的情况，显然多于 2 块和 2 块的情况是一样的 若存在 x 种长度的数量超过 2 ，则取 k 块的答案为 \left(\begin{matrix} 2x \\ k \end{matrix}\right) 答案就是上面两种情况的卷积 代码实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115#include&lt;cstdio&gt;#include&lt;algorithm&gt;#define r registerinline bool isd(r char ch) &#123; return ch&lt;='9'&amp;&amp;ch&gt;='0';&#125;template&lt;class temp&gt;inline temp F() &#123; r temp x=0; r bool bo=0; r char ch=getchar(); while(ch!='-'&amp;&amp;!isd(ch)) ch=getchar(); (ch=='-')&amp;&amp;(bo=1,ch=getchar()); while(isd(ch)) x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^'0'),ch=getchar(); bo&amp;&amp;(x=-x); return x;&#125;const int mod=998244353;int inv[300001],fac[300001],ifc[300001];int A[1200001],B[1200001];int q[300001];int lim=1,lg=0;inline int C(r int x,r int y) &#123; return 1ll*fac[x]*ifc[y]%mod*ifc[x-y]%mod;&#125;int Qpow(r int x,r int y) &#123; r int ret=1; while(y) &#123; if(y&amp;1) ret=1ll*ret*x%mod; x=1ll*x*x%mod,y&gt;&gt;=1; &#125; return ret;&#125;inline int Add(r int a,r int b) &#123; return a+b&gt;=mod?a+b-mod:a+b;&#125;inline int Sub(r int a,r int b) &#123; return a-b&lt;0?a-b+mod:a-b;&#125;int G[2][25];int p[1200001];void Calc() &#123; for(r int i=0;i&lt;lim;++i) p[i]=(p[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(lg-1));&#125;void NTT(int *x,r bool inv) &#123; for(r int i=0;i&lt;lim;++i) if(i&lt;p[i]) std::swap(x[i],x[p[i]]); for(r int mid=1,o=1;mid&lt;lim;mid&lt;&lt;=1,++o) &#123; r int Wn=G[inv][o]; for(r int t=mid&lt;&lt;1,i=0;i&lt;lim;i+=t) for(r int j=0,w=1;j&lt;mid;++j,w=1ll*w*Wn%mod) &#123; r int t1=x[i+j],t2=1ll*x[i+j+mid]*w%mod; x[i+j]=Add(t1,t2); x[i+j+mid]=Sub(t1,t2); &#125; &#125;&#125; int ans[1200001];int main() &#123; G[0][23]=Qpow(3,119); G[1][23]=Qpow(G[0][23],mod-2); for(r int i=22;i;--i) &#123; G[0][i]=1ll*G[0][i+1]*G[0][i+1]%mod; G[1][i]=1ll*G[1][i+1]*G[1][i+1]%mod; &#125; r int n=F&lt;int&gt;(),k=F&lt;int&gt;(),x,y; for(r int i=1;i&lt;=n;++i) x=F&lt;int&gt;(),++q[x]; inv[1]=fac[0]=fac[1]=ifc[0]=ifc[1]=1; for(r int i=2;i&lt;=n;++i) &#123; inv[i]=1ll*(mod-mod/i)*inv[mod%i]%mod; fac[i]=1ll*i*fac[i-1]%mod; ifc[i]=1ll*inv[i]*ifc[i-1]%mod; &#125; for(r int i=1;i&lt;=k;++i) &#123; r int t=F&lt;int&gt;(); x=y=0; for(r int j=1;j&lt;t;++j) if(q[j]==1) ++x; else if(q[j]&gt;1) ++y; lim=1,lg=0; while(lim&lt;x+2*y+1) lim&lt;&lt;=1,++lg; Calc(); for(r int j=0;j&lt;=x;++j) A[j]=1ll*C(x,j)*Qpow(2,j)%mod; for(r int j=0;j&lt;=2*y;++j) B[j]=C(2*y,j); for(r int j=x+1;j&lt;lim;++j) A[j]=0; for(r int j=2*y+1;j&lt;lim;++j) B[j]=0; NTT(A,0),NTT(B,0); for(r int j=0;j&lt;lim;++j) A[j]=1ll*A[j]*B[j]%mod; NTT(A,1); r int Inv=Qpow(lim,mod-2); for(r int j=0;j&lt;=x+2*y;++j) ans[j+t+1]=Add(ans[j+t+1],1ll*A[j]*Inv%mod); &#125; r int Q=F&lt;int&gt;(); while(Q--) &#123; x=F&lt;int&gt;(); printf("%d\n",ans[x/2]); &#125; return 0;&#125; LG 4233 对于每条哈密顿路径，有 2^{\frac{n(n-1)}{2}-n} 个竞赛图包含它 因此 n 个点的竞赛图所包含的哈密顿路径的总数为 (n-1)! 2^{\frac{n(n-1)}{2}-n} 所以我们只需要计算有多少个竞赛图存在哈密顿回路（即是强连通图） 记竞赛图总数 2^{\frac{n(n-1)}{2}} 为 g_n ，强连通竞赛图的数量为 f_n 则 f_i = g_i - \sum\limits_{j=1}^{i-1}f_jg_{i-j} \left(\begin{matrix}i \\ j\end{matrix}\right) g_i=\sum\limits_{j=1}^if_jg_{i-j}\left(\begin{matrix}i \\ j\end{matrix}\right) \frac{g_i}{i!}=\sum\limits_{j=1}^i \frac{f_j}{j!}\frac{g_{i-j}}{(i-j)!} 多项式求逆即可 代码实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113#include&lt;cstdio&gt;#include&lt;algorithm&gt;#define r registerinline bool isd(r char ch) &#123; return ch&lt;='9'&amp;&amp;ch&gt;='0';&#125;template&lt;class temp&gt;inline temp F() &#123; r temp x=0; r bool bo=0; r char ch=getchar(); while(ch!='-'&amp;&amp;!isd(ch)) ch=getchar(); (ch=='-')&amp;&amp;(bo=1,ch=getchar()); while(isd(ch)) x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^'0'),ch=getchar(); bo&amp;&amp;(x=-x); return x;&#125;const int mod=998244353;int Qpow(r int x,r long long y) &#123; r int ret=1; while(y) &#123; if(y&amp;1) ret=1ll*ret*x%mod; x=1ll*x*x%mod,y&gt;&gt;=1; &#125; return ret;&#125;int inv[100001],ifc[100001],fac[100001];int C(r int x,r int y) &#123; return 1ll*fac[x]*ifc[y]%mod*ifc[x-y]%mod;&#125;int f[500001],g[500001],z[500001];int Add(r int a,r int b) &#123; return a+b&gt;=mod?a+b-mod:a+b;&#125;int Sub(r int a,r int b) &#123; return a-b&lt;0?a-b+mod:a-b;&#125;int G[2][25];int p[500001];int lim=1,lg=0;void Calc() &#123; for(r int i=0;i&lt;lim;++i) p[i]=(p[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(lg-1));&#125;void NTT(int *x,r bool inv) &#123; for(r int i=0;i&lt;lim;++i) if(i&lt;p[i]) std::swap(x[i],x[p[i]]); for(r int mid=1,o=1;mid&lt;lim;mid&lt;&lt;=1,++o) &#123; r int Wn=G[inv][o]; for(r int t=mid&lt;&lt;1,i=0;i&lt;lim;i+=t) for(r int j=0,w=1;j&lt;mid;++j,w=1ll*w*Wn%mod) &#123; r int t1=x[i+j],t2=1ll*x[i+j+mid]*w%mod; x[i+j]=Add(t1,t2); x[i+j+mid]=Sub(t1,t2); &#125; &#125;&#125; void Inv(r int n,int *x,int *y) &#123; if(n==1) &#123; y[0]=Qpow(x[0],mod-2); return; &#125; Inv((n+1)&gt;&gt;1,x,y); lim=1,lg=0; while(lim&lt;2*n) lim&lt;&lt;=1,++lg; Calc(); for(r int i=0;i&lt;n;++i) z[i]=x[i]; for(r int i=n;i&lt;lim;++i) z[i]=0; NTT(z,0),NTT(y,0); for(r int i=0;i&lt;lim;++i) y[i]=1ll*Sub(2,1ll*z[i]*y[i]%mod)*y[i]%mod; NTT(y,1); r int iv=Qpow(lim,mod-2); for(r int i=0;i&lt;lim;++i) y[i]=1ll*y[i]*iv%mod; for(r int i=n;i&lt;lim;++i) y[i]=0;&#125;int main() &#123; G[0][23]=Qpow(3,119); G[1][23]=Qpow(G[0][23],mod-2); for(r int i=22;i;--i) &#123; G[0][i]=1ll*G[0][i+1]*G[0][i+1]%mod; G[1][i]=1ll*G[1][i+1]*G[1][i+1]%mod; &#125; r int n=F&lt;int&gt;(); inv[1]=fac[0]=fac[1]=ifc[0]=ifc[1]=1; for(r int i=2;i&lt;=n;++i) &#123; inv[i]=1ll*(mod-mod/i)*inv[mod%i]%mod; fac[i]=1ll*i*fac[i-1]%mod; ifc[i]=1ll*inv[i]*ifc[i-1]%mod; &#125; g[0]=1; for(r int i=1;i&lt;=n;++i) g[i]=1ll*Qpow(2,1ll*i*(i-1)/2)*ifc[i]%mod; Inv(n+1,g,f); for(r int i=1;i&lt;=n;++i) f[i]=1ll*Sub(0,f[i])*fac[i]%mod; if(n&gt;=1) puts("1"); if(n&gt;=2) puts("-1"); for(r int i=3;i&lt;=n;++i) printf("%lld\n",1ll*fac[i-1]*Qpow(2,1ll*i*(i-3)/2)%mod*Qpow(f[i],mod-2)%mod); return 0;&#125; CF 1096G 考虑 DP 记 f_{i, j} 为用 i 个数凑出和为 j 的方案数 显然，我们有 f_{i, j} = \sum\limits_{s=1}^k f_{i-1, j-d_s} 显然，答案为 \sum \limits _{i=1}^{9 \times \frac{n}{2}} {f_{\frac{n}{2}, i}}^2 考虑优化 记 g_s=[s \in d] 则式子可以改写成 f_{i, j} = \sum\limits_{s=1}^j f_{i-1, j-s}g_s 我们发现 f_i = f_{i-1}g 又因为 f_0=1 所以 f_i=g^i 多项式快速幂即可 代码实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115#include&lt;cstdio&gt;#include&lt;algorithm&gt;#define r registerinline bool isd(r char ch) &#123; return ch&lt;='9'&amp;&amp;ch&gt;='0';&#125;template&lt;class temp&gt;inline temp F() &#123; r temp x=0; r bool bo=0; r char ch=getchar(); while(ch!='-'&amp;&amp;!isd(ch)) ch=getchar(); (ch=='-')&amp;&amp;(bo=1,ch=getchar()); while(isd(ch)) x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^'0'),ch=getchar(); bo&amp;&amp;(x=-x); return x;&#125;const int mod=998244353;int Qpow(r int x,r int y) &#123; r int ret=1; while(y) &#123; if(y&amp;1) ret=1ll*ret*x%mod; x=1ll*x*x%mod,y&gt;&gt;=1; &#125; return ret;&#125;inline int Add(r int a,r int b) &#123; return a+b&gt;=mod?a+b-mod:a+b;&#125;inline int Sub(r int a,r int b) &#123; return a-b&lt;0?a-b+mod:a-b;&#125;int G[2][25];int p[3000001];int lim=1,lg=0;void Calc() &#123; for(r int i=0;i&lt;lim;++i) p[i]=(p[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(lg-1));&#125;void NTT(int *x,r bool inv) &#123; for(r int i=0;i&lt;lim;++i) if(i&lt;p[i]) std::swap(x[i],x[p[i]]); for(r int mid=1,o=1;mid&lt;lim;mid&lt;&lt;=1,++o) &#123; r int Wn=G[inv][o]; for(r int t=mid&lt;&lt;1,i=0;i&lt;lim;i+=t) for(r int j=0,w=1;j&lt;mid;++j,w=1ll*w*Wn%mod) &#123; r int t1=x[i+j],t2=1ll*x[i+j+mid]*w%mod; x[i+j]=Add(t1,t2); x[i+j+mid]=Sub(t1,t2); &#125; &#125;&#125;int d[3000001],ret[3000001];int lend,lent;int main() &#123; G[0][23]=Qpow(3,119); G[1][23]=Qpow(G[0][23],mod-2); for(r int i=22;i;--i) &#123; G[0][i]=1ll*G[0][i+1]*G[0][i+1]%mod; G[1][i]=1ll*G[1][i+1]*G[1][i+1]%mod; &#125; r int n=F&lt;int&gt;()&gt;&gt;1,k=F&lt;int&gt;(),x; for(r int i=1;i&lt;=k;++i) x=F&lt;int&gt;(),d[x]=1,lend=std::max(lend,x); ret[0]=1; lent=0; r int q=n; while(q) &#123; if(q&amp;1) &#123; lim=1,lg=0; while(lim&lt;lend+lent+1) lim&lt;&lt;=1,++lg; Calc(); NTT(d,0),NTT(ret,0); for(r int i=0;i&lt;lim;++i) ret[i]=1ll*ret[i]*d[i]%mod; NTT(ret,1),NTT(d,1); r int inv=Qpow(lim,mod-2); for(r int i=0;i&lt;lim;++i) &#123; ret[i]=1ll*ret[i]*inv%mod; if(ret[i]) lent=i; &#125; for(r int i=0;i&lt;lim;++i) &#123; d[i]=1ll*d[i]*inv%mod; if(d[i]) lend=i; &#125; &#125; lim=1,lg=0; while(lim&lt;(lend&lt;&lt;1)+1) lim&lt;&lt;=1,++lg; Calc(); NTT(d,0); for(r int i=0;i&lt;lim;++i) d[i]=1ll*d[i]*d[i]%mod; NTT(d,1); r int inv=Qpow(lim,mod-2); for(r int i=0;i&lt;lim;++i) &#123; d[i]=1ll*d[i]*inv%mod; if(d[i]) lend=i; &#125; q&gt;&gt;=1; &#125; r int ans=0; for(r int i=0;i&lt;=lent+1;++i) ans=Add(ans,1ll*ret[i]*ret[i]%mod); printf("%d\n",ans); return 0;&#125; LOJ 2527 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#include&lt;cstdio&gt;#include&lt;algorithm&gt;#define r registerinline bool isd(r char ch) &#123; return ch&lt;='9'&amp;&amp;ch&gt;='0';&#125;template&lt;class temp&gt;inline temp F() &#123; r temp x=0; r bool bo=0; r char ch=getchar(); while(ch!='-'&amp;&amp;!isd(ch)) ch=getchar(); (ch=='-')&amp;&amp;(bo=1,ch=getchar()); while(isd(ch)) x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^'0'),ch=getchar(); bo&amp;&amp;(x=-x); return x;&#125;const int mod=1004535809;int G[2][25];int Qpow(r int x,r int y) &#123; r int ret=1; while(y) &#123; if(y&amp;1) ret=1ll*x*ret%mod; x=1ll*x*x%mod,y&gt;&gt;=1; &#125; return ret;&#125;inline int Add(r int x,r int y) &#123; return x+y&gt;=mod?x+y-mod:x+y;&#125;inline int Sub(r int x,r int y) &#123; return x-y&lt;0?x-y+mod:x-y; &#125;int w[500001];int inv[12000001],fac[12000001],ifc[12000001]; inline int C(r int x,r int y) &#123; return 1ll*fac[x]*ifc[x-y]%mod*ifc[y]%mod;&#125;int f[1200001],g[1200001];int p[1200001];int lim=1,lg=0;void Calc() &#123; for(r int i=0;i&lt;lim;++i) p[i]=(p[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(lg-1));&#125;void NTT(int *x,r bool inv) &#123; for(r int i=0;i&lt;lim;++i) if(i&lt;p[i]) std::swap(x[i],x[p[i]]); for(r int mid=1,o=1;mid&lt;lim;mid&lt;&lt;=1,++o) &#123; r int Wn=G[inv][o]; for(r int t=mid&lt;&lt;1,i=0;i&lt;lim;i+=t) for(r int j=0,w=1;j&lt;mid;++j,w=1ll*w*Wn%mod) &#123; r int t1=x[i+j],t2=1ll*x[i+j+mid]*w%mod; x[i+j]=Add(t1,t2); x[i+j+mid]=Sub(t1,t2); &#125; &#125;&#125;int main() &#123; G[0][21]=Qpow(3,479); G[1][21]=Qpow(G[0][21],mod-2); for(r int i=20;i;--i) &#123; G[0][i]=1ll*G[0][i+1]*G[0][i+1]%mod; G[1][i]=1ll*G[1][i+1]*G[1][i+1]%mod; &#125; r int n=F&lt;int&gt;(),m=F&lt;int&gt;(),s=F&lt;int&gt;(); r int mx=std::max(m,n); for(r int i=0;i&lt;=m;++i) w[i]=F&lt;int&gt;(); inv[1]=fac[1]=fac[0]=ifc[1]=ifc[0]=1; for(r int i=2;i&lt;=mx;++i) &#123; inv[i]=1ll*(mod-mod/i)*inv[mod%i]%mod; fac[i]=1ll*i*fac[i-1]%mod; ifc[i]=1ll*inv[i]*ifc[i-1]%mod; &#125; mx=std::min(n/s,m); for(r int i=0;i&lt;=mx;++i) f[i]=1ll*fac[i]*C(m,i)%mod*fac[n]%mod*Qpow(m-i,n-i*s)%mod*Qpow(1ll*Qpow(fac[s],i)*fac[n-i*s]%mod,mod-2)%mod; for(r int i=0;i&lt;=mx;++i) g[i]=((mx-i)&amp;1?Sub(0,ifc[mx-i]):ifc[mx-i]); lim=1,lg=0; while(lim&lt;2*mx+1) lim&lt;&lt;=1,++lg; Calc(); NTT(f,0),NTT(g,0); for(r int i=0;i&lt;lim;++i) f[i]=1ll*f[i]*g[i]%mod; NTT(f,1); r int Inv=Qpow(lim,mod-2),ans=0; for(r int i=0;i&lt;=mx;++i) ans=(ans+1ll*w[i]*f[mx+i]%mod*ifc[i]%mod*Inv%mod)%mod; printf("%d\n",ans); return 0;&#125;]]></content>
      <categories>
        <category>Math</category>
        <category>Polynomial</category>
      </categories>
      <tags>
        <tag>FFT</tag>
        <tag>Generating Function</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习笔记-动态 DP]]></title>
    <url>%2F2019%2F12%2F17%2F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%8A%A8%E6%80%81%20DP%2F</url>
    <content type="text"><![CDATA[动态 DP先来看一道题给定一棵 n 个点的树，每个点有点权 m 次操作，每次修改一个点的权，并询问当前最大权独立集 n, m \leq {10}^5 思路 考虑没有修改的情况，我们记 f_{i,0 / 1} 表示在以 i 为根的子树中不选 / 选 i 这个点的最大点权 直接 DP 即可 考虑如何修改 我们定义一种新的矩阵乘法 \otimes 对于两个矩阵 \boldsymbol{A, B} ，定义 \boldsymbol{A} \otimes \boldsymbol{B}=\boldsymbol{C} 其中 \boldsymbol{C}_{i, j} = \max\limits_k(\boldsymbol{A}_{i, k}+\boldsymbol{B}_{k, j})]]></content>
      <categories>
        <category>Dynamic Programming</category>
      </categories>
      <tags>
        <tag>Partition</tag>
        <tag>Matrix</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习笔记-点分治]]></title>
    <url>%2F2019%2F12%2F12%2F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%82%B9%E5%88%86%E6%B2%BB%2F</url>
    <content type="text"><![CDATA[点分治点分治可以用来解决一类树上路径信息统计问题对于节点 x ，其子树内的路径可以分为两类一类是经过 x 的路径，一类是不经过 x 的对于经过 x 的路径，又可以分为两种 一种是以 x 为一个端点的路径，另一种是两个端点都不为 x 的路径 而后者又可以由两条属于前者链合并得到 所以，我们可以选取一个根节点 x ，我们先计算在其子树中且经过该节点的路径对答案的贡献，再递归其子树对不经过该节点的路径进行求解 显然，每次选择当前子树的重心作为根节点最优，这样每次递归树的大小就至少会减小一半 因此递归层数为 O(\log n) 层 点分树 / 动态点分治 动态点分治可以在点分治的基础上支持修改边权 / 点权 我们把每次选取的根节点记录下来，构成一个树形结构，称为 点分树 如果每次选取的根节点是重心，则点分树的高度为 O(\log n) 因为修改时原树的形态不会变，所以点分树的形态也不会变 我们发现每个修改操作只会影响到这个节点 x 和 x 在点分树上的祖先 因此在点分树上暴力往上跳即可 相关例题 「ZJOI2007」捉迷藏 给定一棵 n 个点的树，边有边权，初始每个节点都是黑色 需要支持两个操作 反转一个点的颜色，即黑变白，白变黑 查询最远的两个黑点的距离 n \leq {10}^5 ，操作次数 Q \leq 5 \times {10}^5 思路 我们先建出点分树 对于每个节点 x ，我们维护两个可删堆 d_x, {ch}_x d_x 记录以 x 根的连通块里的所有黑点到 x 的距离 ch_x 记录 x 在点分树上的所有子节点 y 的 d_y.top 和 x 自己的颜色信息 再维护一个可删堆 ans 记录所有 ch_x 的最大值和次大值之和 假设要反转节点 x 的颜色，则对于 x 在点分树上的所有祖先 u ，在 d_u 中插入或删除 dist(x, u) ，同时维护 ch 和 ans 对于一个节点 x ，在点分树上只会有 O(\log n) 个祖先，所以可以将 dist(x, u) 先预处理出来，使用时直接查询即可 代码实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247#include&lt;cstdio&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;using std::priority_queue;#define r register#define inf 2147483647inline bool isd(r char ch) &#123; return ch&lt;='9'&amp;&amp;ch&gt;='0';&#125;template&lt;class temp&gt;inline temp F() &#123; r temp x=0; r bool bo=0; r char ch=getchar(); while(ch!='-'&amp;&amp;!isd(ch)) ch=getchar(); (ch=='-')&amp;&amp;(bo=1,ch=getchar()); while(isd(ch)) x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^'0'),ch=getchar(); bo&amp;&amp;(x=-x); return x;&#125;template&lt;class temp&gt;class Heap &#123; private: priority_queue&lt;temp&gt;A,B; void maintain() &#123; while(!B.empty()&amp;&amp;A.top()==B.top()) A.pop(),B.pop(); &#125; public: temp top() &#123; return A.top(); &#125; void pop() &#123; A.pop(); maintain(); &#125; void erase(temp x) &#123; B.push(x); maintain(); &#125; void push(temp x) &#123; A.push(x); &#125; temp second() &#123; temp t=A.top(),ret; pop(); ret=A.top(); A.push(t); return ret; &#125; unsigned size() &#123; return A.size()-B.size(); &#125;&#125;;Heap&lt;int&gt;d[100001],ch[100001],ans;class Graph &#123; public: struct Edge &#123; int to; Edge* nxt; &#125;; typedef Edge* Node; Node Nul,*Head; int Size; void Resize(int siz) &#123; Head=new Node[siz+1]; for(r int i=0;i&lt;=siz;++i) Head[i]=Nul; &#125; void Add(int f,int t) &#123; Node x=new Edge(); x-&gt;to=t; x-&gt;nxt=Head[f],Head[f]=x; &#125;&#125;P;namespace Work1 &#123; int siz[100001]; int p[100001]; int udf[100001]; int dfn[100001]; int dep[100001]; int top[100001]; int tot; int son[100001]; void dfs(r int x) &#123; siz[x]=1; for(r Graph::Node j=P.Head[x];j!=P.Nul;j=j-&gt;nxt) if(j-&gt;to!=p[x]) &#123; p[j-&gt;to]=x; dep[j-&gt;to]=dep[x]+1; dfs(j-&gt;to); siz[x]+=siz[j-&gt;to]; if(siz[son[x]]&lt;siz[j-&gt;to]) son[x]=j-&gt;to; &#125; &#125; void dfs(r int x,r int tp) &#123; udf[dfn[x]=++tot]=x; top[x]=tp; if(son[x]) dfs(son[x],tp); for(r Graph::Node j=P.Head[x];j!=P.Nul;j=j-&gt;nxt) if(j-&gt;to!=p[x]&amp;&amp;j-&gt;to!=son[x]) dfs(j-&gt;to,j-&gt;to); &#125; int LCA(r int x,r int y) &#123; while(top[x]!=top[y]) &#123; if(dep[top[x]]&gt;dep[top[y]]) std::swap(x,y); y=p[top[y]]; &#125; return dfn[x]&lt;dfn[y]?x:y; &#125; inline int dist(r int x,r int y) &#123; return dep[x]+dep[y]-(dep[LCA(x,y)]&lt;&lt;1); &#125; void Init() &#123; dfs(1); dfs(1,1); &#125;&#125;namespace Work2 &#123; int rt,sum; int siz[100001]; int mx[100001]; int dep[100001]; bool vis[100001]; int p[100001]; void GetRoot(r int x,r int fa) &#123; mx[x]=0; siz[x]=1; for(r Graph::Node j=P.Head[x];j!=P.Nul;j=j-&gt;nxt) if(j-&gt;to!=fa&amp;&amp;!vis[j-&gt;to]) &#123; GetRoot(j-&gt;to,x); siz[x]+=siz[j-&gt;to]; mx[x]=std::max(mx[x],siz[j-&gt;to]); &#125; mx[x]=std::max(mx[x],sum-siz[x]); if(mx[rt]&gt;mx[x]) rt=x; &#125; void dfs(r int x,r int f,r int d,Heap&lt;int&gt;&amp;y) &#123; y.push(d); for(r Graph::Node j=P.Head[x];j!=P.Nul;j=j-&gt;nxt) if(j-&gt;to!=f&amp;&amp;!vis[j-&gt;to]) dfs(j-&gt;to,x,d+1,y); &#125; void Build(r int x) &#123; vis[x]=1; for(r Graph::Node j=P.Head[x];j!=P.Nul;j=j-&gt;nxt) if(!vis[j-&gt;to]) &#123; sum=siz[j-&gt;to]; rt=0; GetRoot(j-&gt;to,0); GetRoot(rt,0); dfs(j-&gt;to,0,1,d[rt]); ch[x].push(d[rt].top()); dep[rt]=dep[x]+1; p[rt]=x; Build(rt); &#125; ch[x].push(0); if(ch[x].size()&gt;=2) ans.push(ch[x].top()+ch[x].second()); else if(ch[x].size()) ans.push(ch[x].top()); &#125; void Init(r int n) &#123; sum=n; rt=0; mx[0]=inf; GetRoot(1,0); GetRoot(rt,0); Build(rt); &#125;&#125;char c[11];bool col[100001];int dis[100001][21];using Work2::dep;using Work2::p;int main() &#123; r int n=F&lt;int&gt;(); P.Resize(n); r int x,y; for(r int i=1;i&lt;n;++i) &#123; x=F&lt;int&gt;(),y=F&lt;int&gt;(); P.Add(x,y),P.Add(y,x); &#125; Work1::Init(); Work2::Init(n); for(r int i=1;i&lt;=n;++i) for(r int j=i;j;j=p[j]) dis[i][dep[i]-dep[j]]=Work1::dist(i,j); r int Q=F&lt;int&gt;(); while(Q--) &#123; scanf("%s",c+1); if(c[1]=='G') &#123; if(ans.size()) printf("%d\n",ans.top()); else puts("-1"); &#125; else &#123; r int opt=F&lt;int&gt;(); if(!col[opt]) &#123; if(ch[opt].size()&gt;=2) ans.erase(ch[opt].top()+ch[opt].second()); ch[opt].erase(0); if(ch[opt].size()&gt;=2) ans.push(ch[opt].top()+ch[opt].second()); for(r int i=opt;p[i];i=p[i]) &#123; if(ch[p[i]].size()&gt;=2) ans.erase(ch[p[i]].top()+ch[p[i]].second()); ch[p[i]].erase(d[i].top()); d[i].erase(dis[opt][dep[opt]-dep[p[i]]]); if(d[i].size()) ch[p[i]].push(d[i].top()); if(ch[p[i]].size()&gt;=2) ans.push(ch[p[i]].top()+ch[p[i]].second()); &#125; &#125; else &#123; if(ch[opt].size()&gt;=2) ans.erase(ch[opt].top()+ch[opt].second()); ch[opt].push(0); if(ch[opt].size()&gt;=2) ans.push(ch[opt].top()+ch[opt].second()); for(r int i=opt;p[i];i=p[i]) &#123; if(ch[p[i]].size()&gt;=2) ans.erase(ch[p[i]].top()+ch[p[i]].second()); if(d[i].size()) ch[p[i]].erase(d[i].top()); d[i].push(dis[opt][dep[opt]-dep[p[i]]]); ch[p[i]].push(d[i].top()); if(ch[p[i]].size()&gt;=2) ans.push(ch[p[i]].top()+ch[p[i]].second()); &#125; &#125; col[opt]^=1; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>Graph Theory</category>
        <category>Tree</category>
      </categories>
      <tags>
        <tag>Partition</tag>
        <tag>Centroid</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习笔记-分治 NTT]]></title>
    <url>%2F2019%2F12%2F08%2F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%88%86%E6%B2%BB%20NTT%2F</url>
    <content type="text"><![CDATA[分治 NTT给定一个长度为 n-1 的数列 g_i ，求 f_0, f_1, \ldots ,f_{n-1} ，其中 f_i= \begin{cases} 1 &amp; i=0\\ \sum\limits_{j=1}^i f_{i-j}g_j &amp; i&gt;0\end{cases} 答案 \bmod 998244353 2 \leq n \leq {10}^5 ， 0 \leq g_i &lt;998244353 思路 乍一看这是一个卷积的形式，想到 NTT 但是我们不能利用尚未求得的项卷积 我们考虑每个 f_j 会对 f_i 产生多少贡献，显然只有 f_j g_{i-j} CDQ 分治，先递归处理 [l, mid] ，然后我们考虑 [l, mid] 对 [mid+1,r] 的贡献，最后递归处理 [mid+1,r] 记 lim=mid-l+1 对于一次分治，我们令 a_i=\begin{cases} f_{i+l} &amp;&amp; i &lt; lim \\ 0 &amp;&amp; i \geq lim\end{cases} b_i=g_i 然后将 a 和 b 卷积起来就得到了 [l,mid] 对 [mid+1, r] 的贡献 将 f_i(mid &lt; i \leq r) 加上 \sum\limits_{j=1}^ia_{i-j}b_j 即可 时间复杂度 O(n \log^2 n) 代码实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define r registerinline bool isd(r char ch) &#123; return ch&lt;='9'&amp;&amp;ch&gt;='0';&#125;template&lt;class temp&gt;inline temp F() &#123; r temp x=0; r bool bo=0; r char ch=getchar(); while(ch!='-'&amp;&amp;!isd(ch)) ch=getchar(); (ch=='-')&amp;&amp;(bo=1,ch=getchar()); x=ch^'0',ch=getchar(); while(isd(ch)) x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^'0'),ch=getchar(); bo&amp;&amp;(x=-x); return x;&#125;const int mod=998244353;const int qpow(r int a,r int b) &#123; r int ret=1; while(b) &#123; if(b&amp;1) ret=1ll*ret*a%mod; a=1ll*a*a%mod,b&gt;&gt;=1; &#125; return ret;&#125;int p[5000001];int G[2][24];using std::swap;int Add(r int a,r int b) &#123; return a+b&gt;=mod?a+b-mod:a+b;&#125;int Sub(r int a,r int b) &#123; return a-b&lt;0?a-b+mod:a-b;&#125;int lim=1;void NTT(int *x,r bool inv) &#123; for(r int i=0;i&lt;lim;++i) if(i&lt;p[i]) swap(x[i],x[p[i]]); for(r int mid=1,o=1;mid&lt;lim;mid&lt;&lt;=1,++o) &#123; r int Wn=G[inv][o]; for(r int t=mid&lt;&lt;1,i=0;i&lt;lim;i+=t) &#123; r int w=1; for(r int j=0;j&lt;mid;++j,w=1ll*w*Wn%mod) &#123; r int t1=x[i+j],t2=1ll*w*x[i+j+mid]%mod; x[i+j]=Add(t1,t2); x[i+j+mid]=Sub(t1,t2); &#125; &#125; &#125;&#125;int a[500001],b[500001];int g[500001],f[500001];void Solve(r int lt,r int rt,r int lg) &#123; if(lt==rt) return; r int mid=(lt+rt)&gt;&gt;1; Solve(lt,mid,lg-1); lim=1&lt;&lt;lg; for(r int i=0;i&lt;lim;++i) p[i]=(p[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(lg-1)); memset(a+(lim&gt;&gt;1),0,sizeof(int)*(lim&gt;&gt;1)); memcpy(a,f+lt,sizeof(int)*(lim&gt;&gt;1)); memcpy(b,g,sizeof(int)*lim); NTT(a,0),NTT(b,0); for(r int i=0;i&lt;lim;++i) a[i]=1ll*a[i]*b[i]%mod; NTT(a,1); r int t=qpow(lim,mod-2); for(r int i=0;i&lt;lim;++i) a[i]=1ll*a[i]*t%mod; for(r int i=(lim&gt;&gt;1);i&lt;lim;++i) f[lt+i]=Add(f[lt+i],a[i]); Solve(mid+1,rt,lg-1);&#125;int main() &#123; r int n=F&lt;int&gt;(); G[0][23]=15311432; G[1][23]=qpow(G[0][23],mod-2); for(r int i=22;i&gt;=0;--i) G[0][i]=1ll*G[0][i+1]*G[0][i+1]%mod,G[1][i]=1ll*G[1][i+1]*G[1][i+1]%mod; for(r int i=1;i&lt;n;++i) g[i]=F&lt;int&gt;(); f[0]=1; r int ed=1,o=0; while(ed&lt;n) ed&lt;&lt;=1,++o; Solve(0,ed-1,o); for(r int i=0;i&lt;=n-1;++i) printf("%d ",f[i]); puts(""); return 0;&#125;]]></content>
      <categories>
        <category>Math</category>
        <category>Polynomial</category>
      </categories>
      <tags>
        <tag>FFT</tag>
        <tag>Partition</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习笔记-斜率优化]]></title>
    <url>%2F2019%2F12%2F06%2F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%96%9C%E7%8E%87%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[斜率优化我们先来看一个问题将 a_{1 \ldots n} 划分成若干段，每段的费用为这段数字和的平方再加上 M 求费用和的最小值， 1 \leq n \leq 5 \times {10}^5 记 f_i 表示把前 i 个数划分为若干段费用和的最小值， s_i 为前 i 个数的和 则 f_i = \min\limits_{j&lt;i} (f_j+(s_i-s_j)^2+M) 时间复杂度 O(n^2) ，显然超时 分析 我们假设 k&lt;j&lt;i 如果在 j 处转移比 k 处优，则 f_j+M+(s_i-s_j)^2&lt;f_k+M+(s_i-s_k)^2 即 \frac{(f_j+s_j^2)-(f_k+s_k^2)}{s_j-s_k} &lt; 2s_i 记 g_i = f_i+s_i^2 则 \frac{g_j-g_k}{s_j-s_k} &lt; 2s_i]]></content>
      <categories>
        <category>Dynamic Programming</category>
      </categories>
      <tags>
        <tag>Convex Hull</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习笔记-Stirling 数]]></title>
    <url>%2F2019%2F11%2F12%2F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Stirling%20%E6%95%B0%2F</url>
    <content type="text"><![CDATA[第二类 Stirling 数第二类 Stirling 数 \left\{ \begin{matrix} n\\k \end{matrix} \right\} ，又称 Stirling 子集数，表示把大小为 n 的集合划分为 k 非空个子集的方案数 第二类 Stirling 数有一个递推式 \left\{ \begin{matrix} n\\k \end{matrix} \right\} = k \left\{ \begin{matrix} n - 1\\k \end{matrix} \right\} + \left\{ \begin{matrix} n - 1\\k - 1 \end{matrix} \right\} 我们来理解一下这个递推式 对于一个大小为 n 的集合，我们要把其划分为 k 个非空子集，我们考虑最后一个元素，我们可以把它单独分为一个子集，剩下元素的方案数为 \left\{ \begin{matrix} n - 1\\k - 1 \end{matrix} \right\} ，或者把剩下 n - 1 个元素划分为 k 个子集，再将最后一个元素加入任意一个子集，方案数为 k \left\{ \begin{matrix} n - 1\\k \end{matrix} \right\} 我们考虑如何快速求出第二类 Stirling 数的一行 通过容斥原理，我们可以推出 \left\{ \begin{matrix} n\\k \end{matrix} \right\} = \frac{1}{k!}\sum\limits_{i=0}^{k} (-1)^i \left(\begin{matrix} k\\i \end{matrix}\right)(k-i)^n = \sum\limits_{i=0}^k \frac{(-1)^i}{i!}\frac{(k-i)^n}{(k-i)!} 即枚举空集个数，求出空集不少于 i 个的答案，容斥 因为集合没有顺序，因此答案要除以 k! 注意到这是一个卷积的形式，因此我们能够在 O(n \log n) 的时间内计算出 \left\{ \begin{matrix} n\\0 \end{matrix} \right\}, \left\{ \begin{matrix} n\\1 \end{matrix} \right\}, \left\{ \begin{matrix} n\\2 \end{matrix} \right\}, \ldots , \left\{ \begin{matrix} n\\n \end{matrix} \right\} 第一类 Stirling 数 第一类 Stirling 数 \left[ \begin{matrix} n \\ k \end{matrix} \right] ，又称 Stirling 轮换数，表示把 n 个元素排成 k 个环形排列的方案数 类似的，第一类 Stirling 数的递推式为 \left[ \begin{matrix} n \\ k \end{matrix} \right]=(n-1)\left[ \begin{matrix} n - 1 \\ k \end{matrix} \right] + \left[ \begin{matrix} n - 1 \\ k - 1 \end{matrix} \right] 同样考虑最后一个元素，其单独拿出，剩下元素的方案数为 \left[ \begin{matrix} n - 1 \\ k - 1 \end{matrix} \right] ，将其放入 k 个环形排列的任意一个中，对于一个排列 P ，方案数为 |P|\left[ \begin{matrix} n - 1 \\ k \end{matrix} \right] ，因为一共有 n-1 个元素，所以 这一类的总方案数为 (n - 1)\left[ \begin{matrix} n - 1 \\ k \end{matrix} \right] 对于第一类 Stirling 数的一行有 \sum\limits_{k=0}^n \left[ \begin{matrix} n \\ k \end{matrix} \right] = n! 下降 / 上升阶乘幂 x 的 k 次下降阶乘幂 x^{\underline{k}} 定义为 \frac{x!}{(x-k)!} = \prod\limits_{i=0}^{k-1}(x-i) x 的 k 次上升阶乘幂 x^{\overline{k}} 定义为 \frac{(x+k-1)!}{(x-1)!} = \prod\limits_{i=0}^{k-1}(x+i) 阶乘幂和通常幂之间的关系可以用 Stirling 数表示 x^n = \sum\limits_{k=0}^{n} \left\{ \begin{matrix} n \\ k \end{matrix} \right\} x^{\underline{k}} 我们可以用归纳法简单证明这个式子 对于上升幂 x^n = \sum\limits_{k=0}^{n} \left\{ \begin{matrix} n \\ k \end{matrix} \right\} (-1)^{n-k} x^{\overline{k}} 有了这个两个式子，我们就可以快速地将通常幂转化为阶乘幂 对于阶乘幂转化为通常幂，有 x^{\overline{n}} = \sum\limits_{k=0}^n\left[ \begin{matrix} n \\ k \end{matrix} \right] x^k x^{\underline{n}} =\sum\limits_{k=0}^n \left[ \begin{matrix} n \\ k \end{matrix} \right] (-1)^{n-k} x^k 同样可以简单用归纳法证明 对于和 (\sum\limits_{i=1}^n i^k) \bmod p ，我们可以用 Stirling 数快速求出 推个式子 \sum\limits_{i=1}^n i^k=\sum\limits_{i=1}^n \sum\limits_{j=0}^k \left\{ \begin{matrix} k \\ j \end{matrix} \right\} i^{\underline{j}}=\sum\limits_{j=0}^k \left\{ \begin{matrix} k \\ j \end{matrix} \right\}\sum\limits_{i=1}^n i^{\underline{j}}=\sum\limits_{j=0}^k \left\{ \begin{matrix} k \\ j \end{matrix} \right\} \frac{(n+1)^{\underline{j+1}}}{j+1} 可以在 O(k \log k) 的时间内求出答案 Stirling 反演 对于两个数列 \{ p_n \}, \{ q_n \} q_n=\sum\limits_{i=0}^n \left\{ \begin{matrix} n \\ i \end{matrix} \right\}p_i \Leftrightarrow p_n=\sum\limits_{i=0}^n (-1)^{n-i} \left[ \begin{matrix} n \\ i \end{matrix} \right] q_i 证明如下 首先我们有下面两个反转公式 \sum\limits_{k=m}^n (-1)^{n-k} \left[ \begin{matrix} n \\ k \end{matrix} \right]\left\{ \begin{matrix} k \\ m \end{matrix} \right\} = [m=n] \sum\limits_{k=m}^n (-1)^{n-k} \left\{ \begin{matrix} n \\ k \end{matrix} \right\}\left[ \begin{matrix} k \\ m \end{matrix} \right] = [m=n] 下面我们开始证明 若已知 p_n=\sum\limits_{i=0}^n (-1)^{n-i} \left[ \begin{matrix} n \\ i \end{matrix} \right] q_i 则 q_n=\sum\limits_{i=0}^n[n=i]q_i=\sum\limits_{i=0}^n\sum\limits_{j=i}^n (-1)^{j-i} \left\{ \begin{matrix} n \\ j \end{matrix} \right\}\left[ \begin{matrix} j \\ i \end{matrix} \right]q_i=\sum\limits_{i=0}^n \left\{ \begin{matrix} n \\ i \end{matrix} \right\} \sum\limits_{j=0}^i(-1)^{i-j} \left[ \begin{matrix} i \\ j \end{matrix} \right]q_j = \sum\limits_{i=0}^n \left\{ \begin{matrix} n \\ i \end{matrix} \right\}p_i]]></content>
      <categories>
        <category>Math</category>
        <category>Discrete Mathematics</category>
      </categories>
      <tags>
        <tag>Combinatorics</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习笔记-CDQ 分治]]></title>
    <url>%2F2019%2F11%2F11%2F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-CDQ%20%E5%88%86%E6%B2%BB%2F</url>
    <content type="text"><![CDATA[CDQ 分治CDQ 分治说是算法，实际上是一种思想因此 CDQ 分治涵盖的范围非常广大概可以分为以下三类CDQ 分治解决和点对有关的问题对于一个长度为 n 的序列，求满足一种性质的点对 (i, j) 数量，或求一个函数 f(i, j) 的最值 CDQ 分治的算法流程是这样的 对于序列 (l, r) 找到序列中点 mid 将所有点对 (i, j) 分为三类 l \leq i \leq j \leq mid l \leq i \leq mid &lt; j \leq r mid &lt; i \leq j \leq r 将序列 (l, r) 拆成 (l, mid) 和 (mid+1, r) 递归求解第一类和第三类点对的答案 处理第二类点对的答案 可以看出， CDQ 分治的重点在于如何处理第二类点对的答案 三维偏序 给定一个序列，每个点有两个属性 (a, b) ，求满足 i &lt; j, a_i &lt; a_j, b_i &lt; b_j 的点对 (i, j) 数量 显然可以 \mbox{BIT} 套权值线段树解决 空间 / 常数太大 我们考虑如何用 CDQ 点分治来解决这个问题 对于区间 (l, r) ，我们可以对 (l, mid), (mid+1, r) 两个区间按照 a 的值分别排序 对于每个 j ，我们把 a_i &lt; a_j 的点的 b 值依次插入一棵 \mbox{BIT} 中 然后查询 b &lt; b_j 的点的数量，统计到答案里面 这样我们的时间复杂度就是 T(n) = 2T(\frac{n}{2})+O(n \log n) = O(n \log^2 n) 的 CDQ 分治优化 1D / 1D 动态规划的转移 1D / 1D 动态规划指状态数和转移都是 O(n) 的一类 DP 问题，朴素做法的时间复杂度为 O(n^2) 如果条件良好的话，可以用 CDQ 分治优化至 O(n \log^2 n) 二维最长上升子序列 给定一个序列，每个元素有两个属性 (a, b) ，求 a, b 都递增的子序列的最大长度 容易列出下面的转移方程 f_i=\max\limits_{j=1}^{i-1} f_j[a_j&lt;a_i][b_j&lt;b_i]+1 直接转移显然是 O(n^2) 的 我们考虑如何用 CDQ 分治优化 对于区间 (l, r) ，我们考虑如何去处理 l \leq j \leq mid &lt; i \leq r 的转移关系 对于每个 i ，我们把 a_j &lt; a_i 的点按照 b_j 将 f_i 值依次插入一棵 \mbox{BIT} 中 然后查询 b &lt; b_i 的前缀 \max 转移 注意每次转移的时候前一半的 f 需要被计算出来，因此在转移之前先递归处理 (l, mid) 的 f l = r 时，说明我们的 f_r 已经被计算好了，给 f_r 加一然后返回即可 时间复杂度同样是 O(n \log^2 n) CDQ 分治将动态问题化为静态 我们常常会遇到一些带修改的序列问题 这时我们可以对时间进行 CDQ 分治 我们将所有操作离线 我们发现每一个修改只会对它之后的询问产生影响 而这样的修改 - 询问关系一共会有 O(n^2) 对 假设我们正在处理的操作序列是 (l, r) 我们可以先处理所有 1 \leq i \leq mid &lt; j \leq r 的修改 - 询问关系 (i, j) ，然后递归处理 (i, mid) 和 (mid+1, r) 注意一点，如果这个操作不是独立的话，需要先递归处理 (i, mid) 的修改 - 询问 矩形加 / 矩形求和 维护一个二维平面，支持两个操作，矩形区域加一个数，矩形求和 咕咕咕。]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Partition</tag>
        <tag>Offline Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习笔记-矩阵]]></title>
    <url>%2F2019%2F11%2F09%2F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%9F%A9%E9%98%B5%2F</url>
    <content type="text"><![CDATA[矩阵由 m \times n 个数 a_{i, j} 排成的 m 行 n 列的数表称为 m 行 n 列的矩阵，简称 m \times n 矩阵。记作： \left[ \begin{matrix} a_{1, 1} &amp; a_{1, 2} &amp; \cdots &amp; a_{1, n} \\ a_{2, 1} &amp; a_{2, 2} &amp; \cdots &amp; a_{2, n} \\ a_{3, 1} &amp; a_{3, 2} &amp; \cdots &amp; a_{3, n} \\ \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\ a_{m, 1} &amp; a_{m, 2} &amp; \cdots &amp; a_{m, n} \end{matrix} \right] 这 m \times n 个数称为矩阵 \boldsymbol{A} 的元素，简称为元，数 a_{i, j} 位于矩阵 \boldsymbol{A} 的第 i 行第 j 列，称为矩阵 \boldsymbol{A} 的 (i, j) 元，以数 a_{i, j} 为 (i, j) 元的矩阵可记为 (a_{i, j}) 或 (a_{i, j})_{m \times n} ， m \times n 矩阵 \boldsymbol{A} 也记作 \boldsymbol{A_{mn}} 行数与列数都等于 n 的矩阵称为 n 阶矩阵或 n 阶方阵 对于 n 阶矩阵 \boldsymbol{A} ，主对角线是指左上角到右下角的对角线。 主对角线中有序的元素集合 a_{1, 1}, a_{2, 2}, \ldots, a_{n, n} 称为对角元素 主对角线上元素为 1 ，其余位置元素为 0 的矩阵叫做单位矩阵，记作 \boldsymbol{I} 基本运算 加法/减法 只有同型矩阵才能进行加法/减法 \left[ \begin{matrix} a &amp; b \\ c &amp; d \end{matrix} \right] \pm \left[ \begin{matrix} e &amp; f \\ g &amp; h \end{matrix} \right] = \left[ \begin{matrix} a \pm e &amp; b \pm f \\ c \pm g &amp; d \pm h \end{matrix} \right] 对于同型矩阵 \boldsymbol{A, B, C} \boldsymbol{A} + \boldsymbol{B} = \boldsymbol{B} + \boldsymbol{A} \boldsymbol{A} + (\boldsymbol{B} + \boldsymbol{C}) = (\boldsymbol{A} + \boldsymbol{B}) + \boldsymbol{C} 数乘 \lambda \cdot \left[ \begin{matrix} a &amp; b \\ c &amp; d \end{matrix} \right] = \left[ \begin{matrix} \lambda a &amp; \lambda b \\ \lambda c &amp; \lambda d \end{matrix} \right] 矩阵的数乘满足以下运算律 \lambda (\mu \boldsymbol{A}) = \mu (\lambda \boldsymbol{A}) \lambda (\mu \boldsymbol{A}) = (\lambda \mu) \boldsymbol{A} (\lambda + \mu) \boldsymbol{A} = \lambda \boldsymbol{A} + \mu \boldsymbol{A} \lambda (\boldsymbol{ A + B }) = \lambda \boldsymbol {A} + \lambda \boldsymbol{ B } 转置 把矩阵 \boldsymbol{A} 的行和列交换所产生的矩阵称为 \boldsymbol{A} 的转置矩阵，记作 \boldsymbol{A^T} ，这一过程称为矩阵的转置 \left[ \begin{matrix} a &amp; b &amp; c \\ d &amp; e &amp; f \end{matrix} \right] ^ T = \left[ \begin{matrix} a &amp; d \\ b &amp; e \\ c &amp; f \end{matrix} \right] 矩阵的转置满足以下运算律： (\boldsymbol{A^T})^\boldsymbol{T}=\boldsymbol{A} (\lambda \boldsymbol{A})^\boldsymbol{T}=\lambda \boldsymbol{A^T} (\boldsymbol{AB})^\boldsymbol{T} = \boldsymbol{B^TA^T} 矩阵乘法 矩阵乘法只有在第一个矩阵 \boldsymbol{A} 的列数与第二个矩阵 \boldsymbol{B} 的行数相等时才有意义 设 \boldsymbol{A} 为 m \times p 的矩阵， \boldsymbol{B} 为 p \times n 的矩阵，它们的乘积 \boldsymbol{C} 是一个 m \times n 的矩阵，记作 \boldsymbol{C}=\boldsymbol{AB} c_{i, j} = \sum\limits_{k=1}^p a_{i, k}b_{k, j} 矩阵乘法满足以下运算律： (\boldsymbol{AB})\boldsymbol{C} = \boldsymbol{A}(\boldsymbol{BC}) (\boldsymbol{A+B})\boldsymbol{C} = \boldsymbol{AC + BC} \boldsymbol{A}(\boldsymbol{B+C}) = \boldsymbol{AB + AC} 矩阵乘法不满足交换律 12345678910111213141516171819202122232425262728template&lt;int n,int m&gt; struct matrix &#123; int val[n+1][m+1]; int *operator[](int i) &#123; return val[i]; &#125; const int *operator[](int i)const &#123; return val[i]; &#125; &#125;;template&lt;int n,int m,int p&gt;matrix&lt;n,m&gt;operator*(const matrix&lt;n,p&gt;&amp;a,const matrix&lt;p,m&gt;&amp;b) &#123; static matrix&lt;n,m&gt;c; int *C; const int *B; long long A; memset(&amp;c,0,sizeof c); for(register int i=1;i&lt;=n;++i) &#123; int j=1; for(C=c[i];j&lt;=p;++j) if(A=a[i][j]) &#123; int k=1; for(B=b[j];k&lt;=m;++k) C[k]+=A*B[k]; &#125; &#125; return c;&#125; 矩阵快速幂 对于方阵 \boldsymbol{A} ，正整数 k ，规定 \boldsymbol{A}^k = \begin{matrix} \underbrace{\boldsymbol{A} \cdot \boldsymbol{A} \ldots \boldsymbol{A}} \\ k\end{matrix} ，即 k 个 \boldsymbol{A} 的连乘积 特别的，规定 \boldsymbol{A}^0 = \boldsymbol{I} 因为矩阵乘法满足结合律，因此我们可以用快速幂的方法快速计算 \boldsymbol{A}^k 1234567891011template&lt;int n&gt;matrix&lt;n,n&gt;qpow(matrix&lt;n,n&gt;&amp;a,long long k) &#123; static matrix&lt;n,n&gt;b,c; b=a,c=I; while(k) &#123; if(k&amp;1) c=c*b; b=b*b,k&gt;&gt;=1; &#125; return c;&#125; 相关例题 求 F_n \bmod 1000000007 ，其中 F_n 表示斐波那契数列的第 n 项， n 在 \mbox{long long} 范围内 思路 我们知道 F_n=F_{n-1}+F_{n-2} ，所以可以递推计算 F_n 但是 n 很大，不能直接递推 我们把递推式写成矩阵的形式 \left( \begin{matrix} F_{n-1} \\ F_n \end{matrix} \right) = \left( \begin{matrix} 0 &amp; 1 \\ 1 &amp; 1 \end{matrix} \right)\left( \begin{matrix} F_{n-2} \\ F_{n-1} \end{matrix} \right) 然后就可以矩阵快速幂求解 代码实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include&lt;cstdio&gt;#include&lt;cstring&gt;#define r registerinline bool isd(r char ch) &#123; return ch&lt;='9'&amp;&amp;ch&gt;='0';&#125;template&lt;class temp&gt;inline temp F() &#123; r temp x=0; r bool bo=0; r char ch=getchar(); while(ch!='-'&amp;&amp;!isd(ch)) ch=getchar(); (ch=='-')&amp;&amp;(bo=1,ch=getchar()); x=ch^'0',ch=getchar(); while(isd(ch)) x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^'0'),ch=getchar(); bo&amp;&amp;(x=-x); return x;&#125;template&lt;int n,int m&gt; struct matrix &#123; int val[n+1][m+1]; int *operator[](int i) &#123; return val[i]; &#125; const int *operator[](int i)const &#123; return val[i]; &#125; &#125;;const int mod=1e9+7;template&lt;int n,int m,int p&gt;matrix&lt;n,m&gt;operator*(const matrix&lt;n,p&gt;&amp;a,const matrix&lt;p,m&gt;&amp;b) &#123; static matrix&lt;n,m&gt;c; int *C; const int *B; long long A; memset(&amp;c,0,sizeof c); for(register int i=1;i&lt;=n;++i) &#123; int j=1; for(C=c[i];j&lt;=p;++j) if(A=a[i][j]) &#123; int k=1; for(B=b[j];k&lt;=m;++k) C[k]=(C[k]+A*B[k])%mod; &#125; &#125; return c;&#125;matrix&lt;2,2&gt;I;template&lt;int n&gt;matrix&lt;n,n&gt;qpow(matrix&lt;n,n&gt;&amp;a,long long k) &#123; static matrix&lt;n,n&gt;b,c; b=a,c=I; while(k) &#123; if(k&amp;1) c=c*b; b=b*b,k&gt;&gt;=1; &#125; return c;&#125;matrix&lt;2,2&gt;a,b;int main() &#123; r long long k=F&lt;long long&gt;(); I[1][1]=1,I[1][2]=0; I[2][1]=0,I[2][2]=1; a[1][1]=0,a[1][2]=1; a[2][1]=1,a[2][2]=1; b=qpow(a,k-1); printf("%lld\n",(0ll+b[1][1]+b[1][2])%mod); return 0;&#125;]]></content>
      <categories>
        <category>Math</category>
        <category>Linear Algebra</category>
      </categories>
      <tags>
        <tag>Matrix</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习笔记-KMP 算法]]></title>
    <url>%2F2019%2F10%2F31%2F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-KMP%20%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[KMP 算法KMP 算法是一个用来解决字符串匹配的算法模式串匹配给定一个主串 S 和一个模式串 P ，判断 P 是否为 S 的字串，并求出匹配位置 BF / Brute Force 算法 从主串 S 的第一位开始，一位位往后匹配，匹配不成功就后移一位重新匹配 时间复杂度 O(|S||P|) ，效率不高 KMP / Knuth-Morris-Pratt 算法 让我们观察 BF 算法的过程 我们发现，经过多次失配以后，我们已经找到了关于模式串 P 的一些信息，我们考虑如何记录并利用这些信息 我们记录一个 \mbox{next}_i 数组表示 P_{1 \ldots i} 的前缀后缀（不能包括自身）相同的最大长度 我们用 i 表示 S 当前遍历到的位置， j 表示 P 当前遍历到的位置 每次失配，就令 j = \mbox{next}_{j-1} ， i 不动，继续匹配 现在我们考虑如何计算 \mbox{next}_i 我们可以借助 \mbox{next}_{1 \ldots i-1} 的值来计算 \mbox{next}_i 实际上这就是模式串 P 和自己匹配的一个过程 总时间复杂度 O(|S|+|P|) 1234567891011121314151617181920void KMP() &#123; int j=0; nxt[1]=0; for(register int i=2;i&lt;=lenp;++i) &#123; while(j&amp;&amp;(p[i]^p[j+1])) j=nxt[j]; if(p[i]==p[j+1]) ++j; nxt[i]=j; &#125; j=0; for(register int i=1;i&lt;=lens;++i) &#123; while(j&amp;&amp;(s[i]^p[j+1])) j=nxt[j]; if(s[i]==p[j+1]) ++j; if(j==lenp) printf("%d\n",j-lenp+1); &#125;&#125; ExKMP / Z-Algorithm 给定一个主串 S 和一个模式串 P ，求 P 与 S 的所有后缀的最长公共前缀 Z-Function 咕咕咕]]></content>
      <categories>
        <category>String</category>
      </categories>
      <tags>
        <tag>Matching</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习笔记-DSU on tree]]></title>
    <url>%2F2019%2F10%2F29%2F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-DSU%20on%20tree%2F</url>
    <content type="text"><![CDATA[DSU on treeDSU on tree 又名树上启发式合并是一种非常优雅的暴力它是用来解决一类树上询问问题，一般这种问题有两个特征 只有对子树的询问 没有修改 举个例子给定一棵树，每个节点有一个颜色，求每个节点子树的颜色种类数 直接暴力是 O(n^2) 的 这时就需要用到 DSU on tree 算法流程 对于每个节点 我们想把子节点的信息直接拿来用 但是子节点的信息会互相影响 每次 DFS 之后都要清除信息 所以我们最多只能保留一个点的信息 考虑保留哪个点的信息最优 很明显保留重儿子 所以每次先 DFS 轻儿子，求出所有轻儿子的答案，并清除信息 最后 DFS 重儿子，不清除信息 这样做时间复杂度为 O(n \log n) 1234567891011121314151617181920212223242526272829void predfs(int x) &#123; size[x]=1; for(Graph::Node j=T.Head[x];j!=T.Nul;j=j-&gt;nxt) if(j-&gt;to!=p[x]) &#123; p[j-&gt;to]=x; predfs(j-&gt;to); size[x]+=size[j-&gt;to]; if(size[j-&gt;to]&gt;size[son[x]]) son[x]=j-&gt;to; &#125; &#125;void update(int x,int d) &#123; cnt[v[x]]+=d; if(~d&amp;&amp;cnt[v[x]]==1) ++tot; for(r Graph::Node j=T.Head[x];j!=T.Nul;j=j-&gt;nxt) if(j-&gt;to!=p[x]&amp;&amp;j-&gt;to!=Son) update(j-&gt;to,d);&#125; void sucdfs(int x,bool h) &#123; for(Graph::Node j=T.Head[x];j!=T.Nul;j=j-&gt;nxt) if(j-&gt;to!=p[x]&amp;&amp;j-&gt;to!=son[x]) sucdfs(j-&gt;to,0); if(son[x]) sucdfs(son[x],1),Son=son[x]; update(x,1),Son=0,ans[x]=tot; if(!h) update(x,-1),tot=0;&#125; 复杂度证明 对原树进行重链剖分 一个点被访问的次数为这个点到根之间的轻边条数 +1 又因为一条路径上的轻边只有 O(\log n) 条 所以总时间复杂度为 O(n \log n) 相关例题 CF 600E Lomsat gelral 给定一棵 n 个节点的树，每个点有一个权值 对于每个节点，求子树内权值的众数和 1\leq n \leq 10^5 思路 模板题，维护当前节点下的最多的权值 代码实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#include&lt;cstdio&gt;#define r registerinline bool isd(r char ch) &#123; return ch&lt;='9'&amp;&amp;ch&gt;='0';&#125;template&lt;class temp&gt;inline temp F() &#123; r temp x=0; r bool bo=0; r char ch=getchar(); while(ch!='-'&amp;&amp;!isd(ch)) ch=getchar(); (ch=='-')&amp;&amp;(bo=1,ch=getchar()); while(isd(ch)) x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^'0'),ch=getchar(); bo&amp;&amp;(x=-x); return x;&#125;class Graph &#123; public: struct Edge &#123; int to; Edge* nxt; &#125;; typedef Edge* Node; Node Nul,*Head; int Size; void Resize(r int siz) &#123; Head=new Node[siz+1]; for(r int i=0;i&lt;=siz;++i) Head[i]=Nul; Size=siz; &#125; void Add(r int f,r int t) &#123; Node x=new Edge(); x-&gt;to=t; x-&gt;nxt=Head[f],Head[f]=x; &#125; void Clear() &#123; Node x,y; for(r int i=0;i&lt;=Size;++i) &#123; x=Head[i]; while(x!=Nul) &#123; y=x-&gt;nxt; delete x; x=y; &#125; &#125; delete []Head; &#125;&#125;T;int v[100001];int son[100001],size[100001],p[100001];void predfs(r int x) &#123; size[x]=1; for(r Graph::Node j=T.Head[x];j!=T.Nul;j=j-&gt;nxt) if(j-&gt;to!=p[x]) p[j-&gt;to]=x,predfs(j-&gt;to),size[x]+=size[j-&gt;to],(size[j-&gt;to]&gt;size[son[x]])&amp;&amp;(son[x]=j-&gt;to);&#125;int cnt[100001],Son,ans=0;long long dp[100001];long long sum=0;void update(r int x,r int d) &#123; cnt[v[x]]+=d; if(~d) &#123; if(cnt[v[x]]&gt;ans) ans=cnt[v[x]],sum=v[x]; else if(cnt[v[x]]==ans) sum+=v[x]; &#125; for(r Graph::Node j=T.Head[x];j!=T.Nul;j=j-&gt;nxt) if(j-&gt;to!=p[x]&amp;&amp;j-&gt;to!=Son) update(j-&gt;to,d);&#125; void sucdfs(r int x,r bool h) &#123; for(r Graph::Node j=T.Head[x];j!=T.Nul;j=j-&gt;nxt) if(j-&gt;to!=p[x]&amp;&amp;j-&gt;to!=son[x]) sucdfs(j-&gt;to,0); if(son[x]) sucdfs(son[x],1),Son=son[x]; update(x,1),Son=0,dp[x]=sum; if(!h) update(x,-1),ans=sum=0;&#125;int main() &#123; r int n=F&lt;int&gt;(),x,y; T.Resize(n); for(r int i=1;i&lt;=n;++i) v[i]=F&lt;int&gt;(); for(r int i=1;i&lt;n;++i) &#123; r int x=F&lt;int&gt;(),y=F&lt;int&gt;(); T.Add(x,y),T.Add(y,x); &#125; predfs(1); sucdfs(1,1); for(r int i=1;i&lt;=n;++i) printf("%lld ",dp[i]); return 0;&#125;]]></content>
      <categories>
        <category>Graph Theory</category>
        <category>Tree</category>
      </categories>
      <tags>
        <tag>Offline Algorithm</tag>
        <tag>Heuristic Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习笔记-Min_25 筛]]></title>
    <url>%2F2019%2F10%2F28%2F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Min_25%20%E7%AD%9B%2F</url>
    <content type="text"><![CDATA[Min_25 筛Min_25 筛是一种能快速求解积性函数 f(x) 的前缀和 F(n) = \sum\limits_{i=1}^n f(i) 的筛法 其中 f(i) 满足 f(p), p \in \mbox{prime} 可以用一些完全积性函数简单表示 同时 f(p ^ k), p \in \mbox{prime} 可以快速计算答案 其主要思想是把 1 \ldots n 这些数按质数和合数分类，然后分别考虑质数和合数的贡献 STAGE 1 我们先来解决一个问题 求 G( m ) = \sum\limits_{i=1}^m [i \in \mbox{prime}] f(i), m \in \{ \lfloor \frac{n}{1} \rfloor, \lfloor \frac{n}{2} \rfloor, \lfloor \frac{n}{3} \rfloor, \ldots, \lfloor \frac{n}{n} \rfloor \} ，共 \sqrt{n} 种取值 我们构造一个函数 f' ，满足： f' 在质数处的取值与 f 相同。即 \forall p \in prime 有 f'(p)=f(p) f' 是完全积性函数 f' 可以快速求前缀和 记 \mbox{minp}(i) 为 i 的最小质因子, P_j 为第 j 个质数 设 g(m, j) = \sum\limits_{i=1}^m [i \in \mbox{prime} \, \mbox{or} \, \mbox{minp}(i)&gt;P_j] f'(i) 即所有质数和最小质因子大于第 j 个质数的 f' 之和 考虑如何递推 如果 P_j &gt; \sqrt{m} ，则 g(m, j) = g(m, j - 1) ，因为不存在 m 以内最小质因子为 P_j 的数 如果 P_j \leq \sqrt{m} ，则 g(m, j) = g(m, j - 1) 再减去一些东西 我们现在来考虑减去的是啥 首先减去的就是那些最小质因子是 P_j 的东西 所以可以提出一个 f'(P_j) 剩下的就是这部分除掉 P_j 的值 容斥一下，先计算带有质数和最小质因子大于等于 P_j 的值 g(\lfloor \frac{n}{p_j} \rfloor, j - 1) 再减掉质数的函数值 \sum\limits_{i=1}^{j-1} f(P_i) ，因为只需用到 \leq \sqrt{m} 的质数，所以这部分可以线筛预处理求出 所以这部分的答案为 g(m, j) = g(m, j - 1) - f'(P_j) [ g(\lfloor \frac{n}{p_j} \rfloor, j - 1) - \sum\limits_{i=1}^{j-1} f(P_i) ] 综上 g(m, j) = \begin{cases} {g(m, j) = g(m, j - 1)}&amp;{P_j &gt; \sqrt{m}}\\ {g(m, j) = g(m, j - 1) - f'(P_j) [ g(\lfloor \frac{n}{p_j} \rfloor, j - 1) - \sum\limits_{i=1}^{j-1} f(P_i) ]}&amp;{P_j \leq \sqrt{m}} \end{cases} 然后我们要求的 G(m) = g(m, |P|) ，这里 |P| 指的是 \leq \sqrt{m} 的质数的个数 这部分的时间复杂度是 O(\frac{n^{\frac{3}{4}}}{\log n}) STAGE 2 现在我们考虑怎么用我们求出来的东西算答案 记 S(m, j) = \sum\limits_{i=1}^m[\mbox{minp}(i) \geq P_j ] f(j) 显然答案为 S(n, 1) + f(1) 考虑如何计算 S(m, j) 首先我们可以分为质数和合数两部分求解 质数部分为 G(m) - \sum\limits_{i=1}^{j-1} f(P_i) 考虑合数部分的贡献 枚举每个合数的最小质因子和最小质因子的次数，就可以转移了 S(m, j) = G(m) - \sum\limits_{i=1}^{j-1} f(P_i) + \sum\limits_{i=j}^{P_i \leq \sqrt{m}} \sum\limits_{e=1}^{P_i^e \leq m} (f(P_i^e)S( \lfloor \frac{n}{p_i^e} \rfloor, i + 1) + f(p_i^{e+1})) 这部分不用记忆化，直接递归，时间复杂度为 O(n^{1-\epsilon}) 一道题 定义积性函数 f(x) ，且 f(p^k)=p^k(p^k-1) ，其中 p \in \mbox{prime} ，求 \sum\limits_{i=1}^n f(x) 。 对 {10}^9+7 取模， 1 \leq n \leq {10}^{10} 思路 预处理 f_1(i) = i^2 和 f_2(i) = i 在质数处的前缀和，在需要用到时相减即可 代码实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include&lt;cstdio&gt;#include&lt;cmath&gt;#define r registerinline bool isd(r char ch) &#123; return ch&lt;='9'&amp;&amp;ch&gt;='0';&#125;template&lt;class temp&gt;inline temp F() &#123; r temp x=0; r bool bo=0; r char ch=getchar(); while(ch!='-'&amp;&amp;!isd(ch)) ch=getchar(); (ch=='-')&amp;&amp;(bo=1,ch=getchar()); while(isd(ch)) x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^'0'),ch=getchar(); bo&amp;&amp;(x=-x); return x;&#125;const int mod=1e9+7,INV6=166666668;long long n;int sqn,cnt;int p[100001];bool isp[100001];long long s[2][100001];void Sieve() &#123; for(r int i=2;i&lt;=sqn;++i) &#123; if(!isp[i]) &#123; p[++cnt]=i; s[0][cnt]=(s[0][cnt-1]+i)%mod; s[1][cnt]=(s[1][cnt-1]+1ll*i*i%mod)%mod; &#125; for(r int j=1;j&lt;=cnt&amp;&amp;1ll*i*p[j]&lt;=sqn;++j) &#123; isp[p[j]*i]=1; if(i%p[j]==0) break; &#125; &#125;&#125;long long G[2][200001];int id[2][100001];int tot;long long val[200001];inline int GetID(r long long w) &#123; return w&lt;=sqn?id[0][w]:id[1][n/w];&#125;inline int Sub(r long long x,r long long y) &#123; return x&gt;=y?x-y:x-y+mod;&#125;void GetG() &#123; for(r long long i=1,j;i&lt;=n;i=j+1) &#123; j=n/(n/i); r long long w=n/i; val[++tot]=w; if(w&lt;=sqn) id[0][w]=tot; else id[1][n/w]=tot; w%=mod; G[0][tot]=w*(w+1)/2%mod; G[1][tot]=w*(w+1)%mod*(2*w+1)%mod*INV6%mod; G[0][tot]=Sub(G[0][tot],1); G[1][tot]=Sub(G[1][tot],1); &#125; for(r int j=1;j&lt;=cnt;++j) &#123; for(r int i=1;i&lt;=tot&amp;&amp;1ll*p[j]*p[j]&lt;=val[i];++i) &#123; r int k=GetID(val[i]/p[j]); G[0][i]=Sub(G[0][i],1ll*p[j]*Sub(G[0][k],s[0][j-1])%mod); G[1][i]=Sub(G[1][i],1ll*p[j]*p[j]%mod*Sub(G[1][k],s[1][j-1])%mod); &#125; &#125;&#125;int GetS(r long long x,r int y) &#123; if(x&lt;p[y]||x&lt;=1) return 0; r int k=GetID(x); r long long res=Sub(Sub(G[1][k],G[0][k]),Sub(s[1][y-1],s[0][y-1])); for(r int i=y;i&lt;=cnt&amp;&amp;p[i]*p[i]&lt;=x;++i) &#123; r long long t1=p[i],t2=1ll*p[i]*p[i]; for(r int j=1;t2&lt;=x;++j,t1=t2,t2*=p[i]) &#123; r long long r1=t1%mod,r2=t2%mod; res=(res+GetS(x/t1,i+1)*r1%mod*Sub(r1,1)%mod+r2*Sub(r2,1)%mod)%mod; &#125; &#125; return res;&#125;int main() &#123; n=F&lt;long long&gt;(); sqn=sqrt(n); Sieve(); GetG(); printf("%d\n",(GetS(n,1)+1)%mod); return 0;&#125;]]></content>
      <categories>
        <category>Math</category>
        <category>Number Theory</category>
      </categories>
      <tags>
        <tag>Sieve</tag>
        <tag>Multiplicative Function</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习笔记-Kruskal 重构树]]></title>
    <url>%2F2019%2F08%2F12%2F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Kruskal%20%E9%87%8D%E6%9E%84%E6%A0%91%2F</url>
    <content type="text"><![CDATA[Kruskal 重构树Kruskal 重构树是一种可以在线维护只保留边权小于某个值的边时，图上的一些问题的算法简单来讲，就是在 Kruskal 算法进行的过程中，把最小生成树的边权改为点权建树模拟 Kruskal 算法的过程 按边权依次遍历每条边 若两点不在一个连通块内 就新建一个结点 p ，将这个点的点权设置为原边的边权 将 p 连向这两点的所在并查集的根 u , v ​ ，更新并查集 遍历完所有边之后，我们就建出了原图的 Kruskal 重构树 12345678910111213141516void Build() &#123; for(register int i=1,ed=(n&lt;&lt;1)-1;i&lt;=ed;++i) p[i]=i; std::sort(E+1,E+m+1); int x,y,cnt=n; for(register int i=1;i&lt;=m;++i) &#123; x=Find(E[i].f),y=Find(E[i].t); if(x!=y) &#123; p[x]=p[y]=++cnt; val[cnt]=E[i].dis; Add(cnt,x),Add(cnt,y); if(cnt-n==n-1) break; &#125; &#125;&#125; 性质 Kruskal 重构树有很多有趣的性质 Kruskal 重构树是一个大/小根堆（除叶子结点外） \mbox{LCA} (u, v) 的权值是 u , v 路径上边权的最大/小值 重构树中代表原树中的点的节点全是叶子节点，其余节点都代表了一条边的边权 相关例题 「NOI2018」归程 一张 n 个点， m 条边的无向连通图，每条边有一个长度 l 和海拔 a Q 次询问，每次给定一个起点 v 和一个水位线 p 每次可以从 v 沿着一些 a&gt;p 的边走到一个节点 u 花费 0 的代价 再从 u 走到 1 花费路径长度的代价 求最小代价，强制在线 n \leq 2 \times 10^5, m \leq 4 \times 10^5, Q \leq 4 \times 10^5, 1 \leq p \leq 10^9, l \leq 10^4, a \leq 10^9 思路 后一段的代价可以把边反向用一遍 Dijkstra 求出 前一段能到达的节点可以在 Kruskal 重构树上倍增求出 在建树的时候记录一下子树内代价的最小值即可 代码实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176#include&lt;cstdio&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#define r register#define inf 2147483647inline bool isd(r char ch) &#123; return ch&lt;='9'&amp;&amp;ch&gt;='0';&#125;template&lt;class temp&gt;inline temp F() &#123; r temp x=0; r bool bo=0; r char ch=getchar(); while(ch!='-'&amp;&amp;!isd(ch)) ch=getchar(); (ch=='-')&amp;&amp;(bo=1,ch=getchar()); while(isd(ch)) x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^'0'),ch=getchar(); bo&amp;&amp;(x=-x); return x;&#125;class Graph &#123; public: struct Edge &#123; int to,dis; Edge* nxt; &#125;; typedef Edge* Node; Node Nul,*Head; int Size; void Resize(r int siz) &#123; Head=new Node[siz+1]; for(r int i=0;i&lt;=siz;++i) Head[i]=Nul; Size=siz; &#125; void Add(r int f,r int t,r int d) &#123; Node x=new Edge(); x-&gt;to=t; x-&gt;dis=d; x-&gt;nxt=Head[f],Head[f]=x; &#125; void Clear() &#123; Node x,y; for(r int i=0;i&lt;=Size;++i) &#123; x=Head[i]; while(x!=Nul) &#123; y=x-&gt;nxt; delete x; x=y; &#125; &#125; delete []Head; &#125;&#125;P,T;int cnt;struct Edge &#123; int f,t,dis;&#125;E[800001];inline bool operator&lt;(r Edge a,r Edge b) &#123; return a.dis&gt;b.dis;&#125;void Add(r int f,r int t,r int dis) &#123; E[++cnt]=(Edge)&#123;f,t,dis&#125;;&#125;struct Node &#123; long long dis; int nm; Node(r long long d,r int i) &#123; dis=d,nm=i; &#125;&#125;;inline bool operator&lt;(r Node a,r Node b) &#123; if(a.dis!=b.dis) return a.dis&gt;b.dis; return a.nm&gt;b.nm;&#125;long long dis[800001];int bin[21],p[800001],val[800001],f[800001][20];int dep[800001];int n,m;int tot;int Find(r int x) &#123; return x==p[x]?x:p[x]=Find(p[x]);&#125;void Dijkstra() &#123; memset(dis,63,sizeof dis); std::priority_queue&lt;Node&gt;q; dis[1]=0; q.push(Node(0,1)); while(!q.empty()) &#123; r Node t=q.top(); q.pop(); if(dis[t.nm]!=t.dis) continue; for(r Graph::Node j=P.Head[t.nm];j!=P.Nul;j=j-&gt;nxt) if(j-&gt;dis+dis[t.nm]&lt;dis[j-&gt;to]) &#123; dis[j-&gt;to]=j-&gt;dis+dis[t.nm]; q.push(Node(dis[j-&gt;to],j-&gt;to)); &#125; &#125;&#125;void Kruskal() &#123; std::sort(E+1,E+m+1); tot=n; for(r int i=1;i&lt;=m;++i) &#123; r int x=Find(E[i].f),y=Find(E[i].t); if(x!=y) &#123; p[x]=p[y]=f[x][0]=f[y][0]=++tot; T.Add(tot,x,0),T.Add(tot,y,0); val[tot]=E[i].dis; if(tot==(n&lt;&lt;1)-1) break; &#125; &#125;&#125;void dfs(r int x) &#123; for(r int i=1;i&lt;=19;++i) if(dep[x]&gt;=bin[i]) f[x][i]=f[f[x][i-1]][i-1]; else break; for(r Graph::Node j=T.Head[x];j!=T.Nul;j=j-&gt;nxt) dep[j-&gt;to]=dep[x]+1,dfs(j-&gt;to),dis[x]=std::min(dis[x],dis[j-&gt;to]);&#125;int Calc(r int x,r int v)&#123; for(r int i=19;i&gt;=0;--i) if(dep[x]&gt;=bin[i]&amp;&amp;val[f[x][i]]&gt;v) x=f[x][i]; return x;&#125;void Main() &#123; cnt=0; memset(dep,0,sizeof dep); memset(f,0,sizeof f); n=F&lt;int&gt;(),m=F&lt;int&gt;(); P.Resize(n),T.Resize(n&lt;&lt;1); r int x,y,l,a; for(r int i=1,ed=(n&lt;&lt;1);i&lt;=ed;++i) p[i]=i; for(r int i=1;i&lt;=n;++i) val[i]=inf; for(r int i=1;i&lt;=m;++i) &#123; x=F&lt;int&gt;(),y=F&lt;int&gt;(),l=F&lt;int&gt;(),a=F&lt;int&gt;(); Add(x,y,a),P.Add(x,y,l),P.Add(y,x,l); &#125; Dijkstra(); Kruskal(); r int o; dep[o=Find(1)]=0; dfs(o); r int Q=F&lt;int&gt;(),k=F&lt;int&gt;(),s=F&lt;int&gt;(),v,p; r long long ans=0; while(Q--) &#123; v=F&lt;int&gt;(),p=F&lt;int&gt;(); v=(v+k*ans-1)%n+1; p=(p+k*ans)%(s+1); r int t=Calc(v,p); printf("%lld\n",ans=dis[t]); &#125; P.Clear(),T.Clear();&#125;int main() &#123; freopen("return.in","r",stdin); freopen("return.out","w",stdout); bin[0]=1; for(r int i=1;i&lt;20;++i) bin[i]=bin[i-1]&lt;&lt;1; r int T=F&lt;int&gt;(); while(T--) Main(); return 0;&#125;]]></content>
      <categories>
        <category>Graph Theory</category>
      </categories>
      <tags>
        <tag>Spanning Tree</tag>
      </tags>
  </entry>
</search>
